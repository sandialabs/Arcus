IP Address Converters
=====================

``Arcus.Converters.IPAddressConverters`` is a static utility class containing conversion methods for converting ``IPAddress`` objects into something else.

Integer Converters
^^^^^^^^^^^^^^^^^^

Integer Converters are used to turn an ``IPAddress`` into an integer value

Netmask To Cidr Route Prefix
----------------------------

.. warning:: This operation only valid for IPv4 netmasks.

``NetmaskToCidrRoutePrefix`` will convert the valid IPv4 ``IPAddress netmask`` into a CIDR route prefix.

.. code-block:: c#

   public static int NetmaskToCidrRoutePrefix(this IPAddress netmask)

The following example generates a table of all route prefixes for the equivalent netmask ``IPAddress`` input. Note that this example uses Gulliver [#Gulliver_001]_ in order to deal with byte manipulation.

.. code-block:: c#
   :emphasize-lines: 15
   :caption: NetmaskToCidrRoutePrefix Example
   :name: NetmaskToCidrRoutePrefix Example

   public void NetmaskToCidrRoutePrefix_Example()
   {
       // equivalent byte value of 255.255.255.255 or 2^32
       var maxIPv4Bytes = Enumerable.Repeat((byte)0xFF, 4).ToArray();

       // build all valid net masks
       var allNetMasks = Enumerable.Range(0, 32 + 1)
           .Select(i => maxIPv4Bytes.ShiftBitsLeft(32 - i))    // use Gulliver to shift bits of byte array
           .Select(b => new IPAddress(b))
           .ToArray();

       var sb = new StringBuilder();
       foreach (var netmask in allNetMasks)
       {
           var routePrefix = netmask.NetmaskToCidrRoutePrefix();

            sb.Append(routePrefix)
                .Append('\t')
                .AppendFormat("{0,-15}", netmask)
                .Append('\t')
                .Append(netmask.GetAddressBytes().ToString("b"))    // using Gulliver to print bytes as bits
                .AppendLine();
       }

       output.WriteLine(sb.ToString());
   }

.. code-block:: none
   :caption: NetmaskToCidrRoutePrefix Example Output
   :name: NetmaskToCidrRoutePrefix Example Output

   0	0.0.0.0        	00000000 00000000 00000000 00000000
   1	128.0.0.0      	10000000 00000000 00000000 00000000
   2	192.0.0.0      	11000000 00000000 00000000 00000000
   3	224.0.0.0      	11100000 00000000 00000000 00000000
   4	240.0.0.0      	11110000 00000000 00000000 00000000
   5	248.0.0.0      	11111000 00000000 00000000 00000000
   6	252.0.0.0      	11111100 00000000 00000000 00000000
   7	254.0.0.0      	11111110 00000000 00000000 00000000
   8	255.0.0.0      	11111111 00000000 00000000 00000000
   9	255.128.0.0    	11111111 10000000 00000000 00000000
   10	255.192.0.0    	11111111 11000000 00000000 00000000
   11	255.224.0.0    	11111111 11100000 00000000 00000000
   12	255.240.0.0    	11111111 11110000 00000000 00000000
   13	255.248.0.0    	11111111 11111000 00000000 00000000
   14	255.252.0.0    	11111111 11111100 00000000 00000000
   15	255.254.0.0    	11111111 11111110 00000000 00000000
   16	255.255.0.0    	11111111 11111111 00000000 00000000
   17	255.255.128.0  	11111111 11111111 10000000 00000000
   18	255.255.192.0  	11111111 11111111 11000000 00000000
   19	255.255.224.0  	11111111 11111111 11100000 00000000
   20	255.255.240.0  	11111111 11111111 11110000 00000000
   21	255.255.248.0  	11111111 11111111 11111000 00000000
   22	255.255.252.0  	11111111 11111111 11111100 00000000
   23	255.255.254.0  	11111111 11111111 11111110 00000000
   24	255.255.255.0  	11111111 11111111 11111111 00000000
   25	255.255.255.128	11111111 11111111 11111111 10000000
   26	255.255.255.192	11111111 11111111 11111111 11000000
   27	255.255.255.224	11111111 11111111 11111111 11100000
   28	255.255.255.240	11111111 11111111 11111111 11110000
   29	255.255.255.248	11111111 11111111 11111111 11111000
   30	255.255.255.252	11111111 11111111 11111111 11111100
   31	255.255.255.254	11111111 11111111 11111111 11111110
   32	255.255.255.255	11111111 11111111 11111111 11111111


String Converters
^^^^^^^^^^^^^^^^^

Unfortunately ``IPAddress`` does not implement ``IFormattable``, and we chose for compatibility sake not to to extend ``IPAddress`` with our own proxy class. This however does not mean we don't want that precious data hidden within.

It should not be a profound world changing experience to realize that string converters will convert ``IPAddress`` to a ``string``. Game changing perhaps, but not world changing.

ToDottedQuadString
------------------

``ToDottedQuadString`` will take the IPv6 input of ``IPAddress ipAddress`` and convert it into a dotted quad representation.

.. warning:: A non-IPv6 input will cause the method to simply return the value of the input ``IPAddress``.

.. code-block:: c#

    public static string ToDottedQuadString(this IPAddress ipAddress)

The example below shows the output generated by calling the ``ToDottedQuadString`` extension method on an ``IPAddress``.

.. code-block:: c#
   :emphasize-lines: 18
   :caption: ToDottedQuadString Example
   :name: ToDottedQuadString Example

    public void ToDottedQuadString_Example()
    {
        var addresses = new[]
        {
            "::",
            "::ffff",
            "a:b:c::ff00:ff",
            "ffff::",
            "ffff::0102:0304",
            "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        }.Select(IPAddress.Parse)
        .ToArray();

        var sb = new StringBuilder();

        foreach (var address in addresses)
        {
            var dottedQuadString = address.ToDottedQuadString();

            sb.AppendFormat("{0,-40}", address)
                .Append('\t').Append("=>").Append('\t')
                .Append(dottedQuadString)
                .AppendLine();
        }

        output.WriteLine(sb.ToString());
    }

.. code-block:: none
   :caption: ToDottedQuadString Example Output
   :name: ToDottedQuadString Example Output

   ::                                      	=>	::0.0.0.0
   ::ffff                                  	=>	::0.0.255.255
   a:b:c::ff00:ff                          	=>	a:b:c::255.0.0.255
   ffff::                                  	=>	ffff::0.0.0.0
   ffff::102:304                           	=>	ffff::1.2.3.4
   ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff 	=>	ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255


ToHexString
-----------

``ToHexString`` may be used to encode the ``IPAddress ipAddress`` as a Big-Endian[#Gulliver_001]_ ordered string. It will keep all zero-valued most significant bytes.

.. code-block:: c#

    public static string ToHexString(this IPAddress ipAddress)

The example below shows the output created by calling the ``ToHexString`` extension method on an ``IPAddress``.

.. code-block:: c#
   :emphasize-lines: 20
   :caption: ToHexString Example
   :name: ToHexString Example

    public void ToHexString_Example()
    {
        var addresses = new[]
        {
            "::",
            "::ffff",
            "10.1.1.1",
            "192.168.1.1",
            "255.255.255.255",
            "ffff::",
            "ffff::0102:0304",
            "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        }.Select(IPAddress.Parse)
        .ToArray();

        var sb = new StringBuilder();

        foreach (var address in addresses)
        {
            var hexString = address.ToHexString();

            sb.AppendFormat("{0,-40}", address)
                .Append('\t').Append("=>").Append('\t')
                .Append(hexString)
                .AppendLine();
        }

        output.WriteLine(sb.ToString());
    }

.. code-block:: none
   :caption: ToHexString Example Output
   :name: ToHexString Example Output

    ::                                      	=>	00000000000000000000000000000000
    ::ffff                                  	=>	0000000000000000000000000000FFFF
    10.1.1.1                                	=>	0A010101
    192.168.1.1                             	=>	C0A80101
    255.255.255.255                         	=>	FFFFFFFF
    ffff::                                  	=>	FFFF0000000000000000000000000000
    ffff::102:304                           	=>	FFFF0000000000000000000001020304
    ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff 	=>	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

ToNumericString
---------------

``ToNumericString`` takes the provided ``IPAddress ipAddress`` and will return a string representing an unsigned integer value of said address.

.. note:: The return value will be somewhere between :math:`0` and :math:`340282366920938463463374607431768211455`.

.. code-block:: c#

    public static string ToNumericString(this IPAddress ipAddress)

The example below shows the output created by calling the ``ToNumericString`` extension method on an ``IPAddress``.

.. code-block:: c#
   :emphasize-lines: 20
   :caption: ToNumericString Example
   :name: ToNumericString Example

    public void ToNumericString_Example()
    {
        var addresses = new[]
        {
            "::",
            "::ffff",
            "10.1.1.1",
            "192.168.1.1",
            "255.255.255.255",
            "ffff::",
            "ffff::0102:0304",
            "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        }.Select(IPAddress.Parse)
        .ToArray();

        var sb = new StringBuilder();

        foreach (var address in addresses)
        {
            var numericString = address.ToNumericString();

            sb.AppendFormat("{0,-40}", address)
                .Append('\t').Append("=>").Append('\t')
                .Append(numericString)
                .AppendLine();
        }

        output.WriteLine(sb.ToString());
    }

.. code-block:: none
   :caption: ToNumericString Example Output
   :name: ToNumericString Example Output

    ::                                      	=>	0
    ::ffff                                  	=>	65535
    10.1.1.1                                	=>	167837953
    192.168.1.1                             	=>	3232235777
    255.255.255.255                         	=>	4294967295
    ffff::                                  	=>	340277174624079928635746076935438991360
    ffff::102:304                           	=>	340277174624079928635746076935455900420
    ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff 	=>	340282366920938463463374607431768211455


ToUncompressedString
--------------------

``ToUncompressedString`` converts the given ``IPAddress ipAddress`` input to an "uncompressed" IPv4 or IPv6 address string.

The function will add appropriate most significant zeros between octects and hextets, as well as expanding '::' to the appropriate zeroed-hextets in IPv6 addresses.

.. code-block:: c#

    public static string ToUncompressedString(this IPAddress ipAddress)

The example below shows the output created by calling the ``ToUncompressedString`` extension method on an ``IPAddress``.

.. code-block:: c#
   :emphasize-lines: 19
   :caption: ToUncompressedString Example
   :name: ToUncompressedString Example

    public void ToUncompressedString_Example()
    {
        var addresses = new[]
        {
            "::",
            "::ffff",
            "10.1.1.1",
            "192.168.1.1",
            "255.255.255.255",
            "ffff::",
            "ffff::0102:0304"
        }.Select(IPAddress.Parse)
        .ToArray();

        var sb = new StringBuilder();

        foreach (var address in addresses)
        {
            var uncompressedString = address.ToUncompressedString();

            sb.AppendFormat("{0,-40}", address)
                .Append('\t').Append("=>").Append('\t')
                .Append(uncompressedString)
                .AppendLine();
        }

        output.WriteLine(sb.ToString());
    }

.. code-block:: none
   :caption: ToUncompressedString Example Output
   :name: ToUncompressedString Example Output

    ::                                      	=>	0000:0000:0000:0000:0000:0000:0000:0000
    ::ffff                                  	=>	0000:0000:0000:0000:0000:0000:0000:ffff
    10.1.1.1                                	=>	010.001.001.001
    192.168.1.1                             	=>	192.168.001.001
    255.255.255.255                         	=>	255.255.255.255
    ffff::                                  	=>	ffff:0000:0000:0000:0000:0000:0000:0000
    ffff::102:304                           	=>	ffff:0000:0000:0000:0000:0000:0102:0304

ToBase85String
--------------

``ToBase85String`` will take an IPv6 ``IPAddress ipAddress`` and convert it to Base85, AKA Ascii85, in accordance to RFC1924 [#RFC1924]_ which defines a "A Compact Representation of IPv6 Addresses".

.. note:: The input of a non-IPv6 address will return an empty string.

.. code-block:: c#

    public static string ToBase85String(this IPAddress ipAddress)

The example below shows the output created by calling the ``ToBase85String`` extension method on an ``IPAddress``.

.. code-block:: c#
   :emphasize-lines: 18
   :caption: ToBase85String Example
   :name: ToBase85String Example

    public void ToBase85String_Example()
    {
        var addresses = new[]
        {
            "::",
            "::ffff",
            "1080:0:0:0:8:800:200C:417A", // specific example from RFC 1924
            "ffff::",
            "ffff::0102:0304",
            "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        }.Select(IPAddress.Parse)
        .ToArray();

        var sb = new StringBuilder();

        foreach (var address in addresses)
        {
            var base85String = address.ToBase85String();

            sb.AppendFormat("{0,-40}", address)
                .Append('\t').Append("=>").Append('\t')
                .Append(base85String)
                .AppendLine();
        }

        output.WriteLine(sb.ToString());
    }


.. code-block:: none
   :caption: ToBase85String Example Output
   :name: ToBase85String Example Output

    ::                                      	=>	00000000000000000000
    ::ffff                                  	=>	00000000000000000960
    1080::8:800:200c:417a                   	=>	4)+k&C#VzJ4br>0wv%Yp
    ffff::                                  	=>	=q{+M|w0(OeO5^EGP660
    ffff::102:304                           	=>	=q{+M|w0(OeO5^EGqpaA
    ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff 	=>	=r54lj&NUUO~Hi%c2ym0

.. rubric:: Footnotes

.. [#Gulliver_001] Interested in byte manipulation? Is endianess is your calling? You should check out `Gulliver <https://github.com/sandialabs/gulliver>`_, an awesome opensource C# library developed by a number of smart and attractive people that like playing with their bits.
.. [#RFC1924] `RFC 1924 <http://tools.ietf.org/html/rfc1924>`_ is an April Fools Day Joke, but we implemented it anyhow. The question is, did we realize it was a joke before we implemented it or not. Ah, programmer jokes. There are 10 types of developers out there, those that get the joke, and those that don't.
